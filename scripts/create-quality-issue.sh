#!/bin/bash

# create-quality-issue.sh - Create quality/technical debt issues with duplicate prevention
# Usage: ./scripts/create-quality-issue.sh "<title>" "<description>" "<keywords>" [--force]

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

log() {
    echo -e "${BLUE}[QUALITY-ISSUE]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Check if gh CLI is authenticated
check_auth() {
    if ! gh auth status >/dev/null 2>&1; then
        error "GitHub CLI not authenticated. Run 'gh auth login' first."
    fi
}

# Determine priority based on keywords
determine_priority() {
    local keywords="$1"
    local description="$2"
    
    # Convert to lowercase for checking
    local text="${keywords,,} ${description,,}"
    
    if [[ $text =~ (security|vulnerability|sql.injection|xss|csrf|auth.bypass|data.loss) ]]; then
        echo "critical"
    elif [[ $text =~ (performance|memory.leak|n\+1|bottleneck|slow.query|timeout) ]]; then
        echo "high"
    elif [[ $text =~ (architecture|coupling|srp.violation|solid|design.pattern) ]]; then
        echo "high"
    elif [[ $text =~ (code.quality|dead.code|magic.number|naming|duplication) ]]; then
        echo "medium"
    else
        echo "low"
    fi
}

# Determine labels based on keywords and content
determine_labels() {
    local keywords="$1"
    local description="$2"
    local labels=("technical-debt")
    
    # Convert to lowercase for checking
    local text="${keywords,,} ${description,,}"
    
    # Add category labels
    if [[ $text =~ (security|vulnerability|auth) ]]; then
        labels+=("security")
    fi
    
    if [[ $text =~ (performance|memory|speed|optimization) ]]; then
        labels+=("performance")
    fi
    
    if [[ $text =~ (architecture|design|pattern|coupling) ]]; then
        labels+=("architecture")
    fi
    
    if [[ $text =~ (test|coverage|mutation) ]]; then
        labels+=("testing")
    fi
    
    if [[ $text =~ (ui|frontend|react|css) ]]; then
        labels+=("frontend")
    fi
    
    if [[ $text =~ (api|backend|database|sql) ]]; then
        labels+=("backend")
    fi
    
    # Add priority label
    local priority=$(determine_priority "$keywords" "$description")
    labels+=("priority:$priority")
    
    # Convert array to comma-separated string
    IFS=','
    echo "${labels[*]}"
}

# Create the GitHub issue
create_issue() {
    local title="$1"
    local description="$2"
    local keywords="$3"
    
    log "Creating quality issue: $title"
    
    # Determine labels and priority
    local labels
    labels=$(determine_labels "$keywords" "$description")
    local priority
    priority=$(determine_priority "$keywords" "$description")
    
    # Create issue body with template
    local issue_body
    issue_body=$(cat <<EOF
## ðŸŽ¯ Quality Issue

**Priority**: ${priority^}
**Category**: Technical Debt
**Keywords**: $keywords

## ðŸ“‹ Description

$description

## ðŸ” Analysis

This issue was automatically detected during code quality analysis.

## âœ… Acceptance Criteria

- [ ] Issue resolved and code quality improved
- [ ] Tests added/updated to prevent regression
- [ ] Documentation updated if necessary
- [ ] Code review completed

## ðŸ”— Related Issues

<!-- This section will be updated automatically if related issues are found -->

---
ðŸ¤– *Auto-generated by WorkFlo Quality Analysis System*
EOF
)
    
    # Create the issue
    local issue_number
    issue_number=$(gh issue create \
        --title "$title" \
        --body "$issue_body" \
        --label "$labels" \
        --json number \
        --jq '.number')
    
    if [[ -n "$issue_number" ]]; then
        success "Created issue #$issue_number: $title"
        
        # Add to project board
        if [[ -f "$SCRIPT_DIR/gh-board-sync.sh" ]]; then
            log "Adding issue to project board..."
            "$SCRIPT_DIR/gh-board-sync.sh" add "$issue_number" >/dev/null 2>&1 || warn "Failed to add to project board"
        fi
        
        echo "$issue_number"
    else
        error "Failed to create issue"
    fi
}

# Update existing issue with additional context
update_existing_issue() {
    local issue_number="$1"
    local new_context="$2"
    
    log "Updating existing issue #$issue_number with additional context"
    
    # Get current issue body
    local current_body
    current_body=$(gh issue view "$issue_number" --json body --jq '.body')
    
    # Add new context to the issue
    local updated_body
    updated_body=$(cat <<EOF
$current_body

---

## ðŸ”„ Additional Context ($(date))

$new_context

EOF
)
    
    # Update the issue
    gh issue edit "$issue_number" --body "$updated_body"
    success "Updated issue #$issue_number with additional context"
}

# Show help
show_help() {
    echo "Quality Issue Creator with Duplicate Prevention"
    echo ""
    echo "Usage: $0 \"<title>\" \"<description>\" \"<keywords>\" [--force]"
    echo ""
    echo "Arguments:"
    echo "  title        The issue title"
    echo "  description  Detailed description of the quality issue"
    echo "  keywords     Comma-separated keywords for categorization"
    echo "  --force      Skip duplicate check and create anyway"
    echo ""
    echo "Examples:"
    echo "  $0 \"Remove hardcoded database connections\" \"Found hardcoded connection strings in CommitService.cs:45\" \"technical-debt,database,security\""
    echo "  $0 \"Extract common validation logic\" \"Duplicate validation code in UserService and TaskService\" \"architecture,duplication,refactor\""
    echo ""
    echo "Priority levels (auto-determined):"
    echo "  critical - Security vulnerabilities, data loss risks"
    echo "  high     - Performance issues, architecture violations"
    echo "  medium   - Code quality issues, maintainability"
    echo "  low      - Minor improvements, cosmetic changes"
}

# Main execution
if [[ $# -lt 3 ]]; then
    show_help
    exit 1
fi

# Check dependencies
if ! command -v gh &> /dev/null; then
    error "GitHub CLI (gh) is required but not installed"
fi

# Parse arguments
TITLE="$1"
DESCRIPTION="$2"
KEYWORDS="$3"
FORCE_CREATE="false"

if [[ $# -ge 4 && "$4" == "--force" ]]; then
    FORCE_CREATE="true"
fi

# Validate inputs
if [[ -z "$TITLE" ]]; then
    error "Title cannot be empty"
fi

if [[ -z "$DESCRIPTION" ]]; then
    error "Description cannot be empty"
fi

if [[ -z "$KEYWORDS" ]]; then
    error "Keywords cannot be empty"
fi

# Check authentication
check_auth

# Check for duplicates unless forced
if [[ "$FORCE_CREATE" != "true" ]]; then
    log "Checking for duplicate issues..."
    
    if "$SCRIPT_DIR/check-duplicate-issues.sh" "$TITLE" "$KEYWORDS" >/dev/null 2>&1; then
        # No duplicates found, proceed with creation
        create_issue "$TITLE" "$DESCRIPTION" "$KEYWORDS"
    else
        # Duplicates found
        warn "Similar issues found. Options:"
        echo "  1. Review existing issues and update with additional context"
        echo "  2. Use --force flag if this is genuinely different"
        echo "  3. Refine title/keywords to be more specific"
        echo ""
        echo "Similar issues:"
        "$SCRIPT_DIR/check-duplicate-issues.sh" "$TITLE" "$KEYWORDS" 2>/dev/null | grep "DUPLICATE_FOUND" | while IFS=':' read -r prefix number title state; do
            echo "  - #$number: $title [$state]"
        done
        
        error "Issue creation blocked due to similar existing issues"
    fi
else
    warn "Forcing issue creation despite potential duplicates"
    create_issue "$TITLE" "$DESCRIPTION" "$KEYWORDS"
fi