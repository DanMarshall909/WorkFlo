//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IAnchorApiClient {

    anchorApiEndpointsVersionGetVersionEndpoint(): Promise<VersionResponse>;

    anchorApiEndpointsAuthCurrentUserEndpoint(): Promise<CurrentUserResponse>;

    anchorApiEndpointsAuthLoginEndpoint(loginRequest: LoginRequest): Promise<AuthResponse>;

    anchorApiEndpointsAuthLogoutEndpoint(logoutRequest: LogoutRequest): Promise<void>;

    anchorApiEndpointsAuthOAuthLoginEndpoint(oAuthLoginRequest: OAuthLoginRequest): Promise<OAuthLoginResponse>;

    anchorApiEndpointsAuthRefreshTokenEndpoint(refreshTokenRequest: RefreshTokenRequest): Promise<RefreshTokenResponse>;

    anchorApiEndpointsAuthRegisterEndpoint(registerRequest: RegisterRequest): Promise<AuthResponse>;

    anchorApiEndpointsAuthResendVerificationEndpoint(resendVerificationRequest: ResendVerificationRequest): Promise<VerificationResponse>;

    anchorApiEndpointsAuthVerifyEmailEndpoint(verifyEmailRequest: VerifyEmailRequest): Promise<VerificationResponse>;

    getRoot(): Promise<void>;
}

export class AnchorApiClient implements IAnchorApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://localhost:5000";
    }

    anchorApiEndpointsVersionGetVersionEndpoint(): Promise<VersionResponse> {
        let url_ = this.baseUrl + "/api/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsVersionGetVersionEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsVersionGetVersionEndpoint(response: Response): Promise<VersionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionResponse>(null as any);
    }

    anchorApiEndpointsAuthCurrentUserEndpoint(): Promise<CurrentUserResponse> {
        let url_ = this.baseUrl + "/api/auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthCurrentUserEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthCurrentUserEndpoint(response: Response): Promise<CurrentUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrentUserResponse>(null as any);
    }

    anchorApiEndpointsAuthLoginEndpoint(loginRequest: LoginRequest): Promise<AuthResponse> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthLoginEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthLoginEndpoint(response: Response): Promise<AuthResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResponse>(null as any);
    }

    anchorApiEndpointsAuthLogoutEndpoint(logoutRequest: LogoutRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(logoutRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthLogoutEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthLogoutEndpoint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    anchorApiEndpointsAuthOAuthLoginEndpoint(oAuthLoginRequest: OAuthLoginRequest): Promise<OAuthLoginResponse> {
        let url_ = this.baseUrl + "/api/auth/oauth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(oAuthLoginRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthOAuthLoginEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthOAuthLoginEndpoint(response: Response): Promise<OAuthLoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OAuthLoginResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OAuthLoginResponse>(null as any);
    }

    anchorApiEndpointsAuthRefreshTokenEndpoint(refreshTokenRequest: RefreshTokenRequest): Promise<RefreshTokenResponse> {
        let url_ = this.baseUrl + "/api/auth/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshTokenRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthRefreshTokenEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthRefreshTokenEndpoint(response: Response): Promise<RefreshTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RefreshTokenResponse>(null as any);
    }

    anchorApiEndpointsAuthRegisterEndpoint(registerRequest: RegisterRequest): Promise<AuthResponse> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthRegisterEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthRegisterEndpoint(response: Response): Promise<AuthResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthResponse>(null as any);
    }

    anchorApiEndpointsAuthResendVerificationEndpoint(resendVerificationRequest: ResendVerificationRequest): Promise<VerificationResponse> {
        let url_ = this.baseUrl + "/api/auth/resend-verification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendVerificationRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthResendVerificationEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthResendVerificationEndpoint(response: Response): Promise<VerificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationResponse>(null as any);
    }

    anchorApiEndpointsAuthVerifyEmailEndpoint(verifyEmailRequest: VerifyEmailRequest): Promise<VerificationResponse> {
        let url_ = this.baseUrl + "/api/auth/verify-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(verifyEmailRequest);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAnchorApiEndpointsAuthVerifyEmailEndpoint(_response);
        });
    }

    protected processAnchorApiEndpointsAuthVerifyEmailEndpoint(response: Response): Promise<VerificationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerificationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerificationResponse>(null as any);
    }

    getRoot(): Promise<void> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoot(_response);
        });
    }

    protected processGetRoot(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class VersionResponse implements IVersionResponse {
    apiName?: string;
    message?: string;
    version?: string;
    informationalVersion?: string;
    buildDate?: Date;
    gitCommit?: string;
    environment?: string;

    constructor(data?: IVersionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiName = _data["apiName"];
            this.message = _data["message"];
            this.version = _data["version"];
            this.informationalVersion = _data["informationalVersion"];
            this.buildDate = _data["buildDate"] ? new Date(_data["buildDate"].toString()) : <any>undefined;
            this.gitCommit = _data["gitCommit"];
            this.environment = _data["environment"];
        }
    }

    static fromJS(data: any): VersionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VersionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiName"] = this.apiName;
        data["message"] = this.message;
        data["version"] = this.version;
        data["informationalVersion"] = this.informationalVersion;
        data["buildDate"] = this.buildDate ? this.buildDate.toISOString() : <any>undefined;
        data["gitCommit"] = this.gitCommit;
        data["environment"] = this.environment;
        return data;
    }
}

export interface IVersionResponse {
    apiName?: string;
    message?: string;
    version?: string;
    informationalVersion?: string;
    buildDate?: Date;
    gitCommit?: string;
    environment?: string;
}

export class CurrentUserResponse implements ICurrentUserResponse {
    id?: string;
    emailHash?: string;
    emailVerified?: boolean;
    createdAt?: Date;
    isActive?: boolean;

    constructor(data?: ICurrentUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailHash = _data["emailHash"];
            this.emailVerified = _data["emailVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CurrentUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailHash"] = this.emailHash;
        data["emailVerified"] = this.emailVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICurrentUserResponse {
    id?: string;
    emailHash?: string;
    emailVerified?: boolean;
    createdAt?: Date;
    isActive?: boolean;
}

export class AuthResponse implements IAuthResponse {
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: Date;
    user?: UserInfo;

    constructor(data?: IAuthResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.user = _data["user"] ? UserInfo.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAuthResponse {
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: Date;
    user?: UserInfo;
}

export class UserInfo implements IUserInfo {
    id?: string;
    emailHash?: string;
    emailVerified?: boolean;
    createdAt?: Date;

    constructor(data?: IUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailHash = _data["emailHash"];
            this.emailVerified = _data["emailVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailHash"] = this.emailHash;
        data["emailVerified"] = this.emailVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserInfo {
    id?: string;
    emailHash?: string;
    emailVerified?: boolean;
    createdAt?: Date;
}

export class LoginRequest implements ILoginRequest {
    email!: string;
    password!: string;
    rememberMe?: boolean;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginRequest {
    email: string;
    password: string;
    rememberMe?: boolean;
}

export class LogoutRequest implements ILogoutRequest {
    refreshToken!: string;

    constructor(data?: ILogoutRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): LogoutRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ILogoutRequest {
    refreshToken: string;
}

export class OAuthLoginResponse implements IOAuthLoginResponse {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    expiresAt?: Date | undefined;
    isNewUser?: boolean;
    user?: UserInfo2 | undefined;
    error?: string | undefined;

    constructor(data?: IOAuthLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.isNewUser = _data["isNewUser"];
            this.user = _data["user"] ? UserInfo2.fromJS(_data["user"]) : <any>undefined;
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): OAuthLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["isNewUser"] = this.isNewUser;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["error"] = this.error;
        return data;
    }
}

export interface IOAuthLoginResponse {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    expiresAt?: Date | undefined;
    isNewUser?: boolean;
    user?: UserInfo2 | undefined;
    error?: string | undefined;
}

export class UserInfo2 implements IUserInfo2 {
    id?: string;
    emailHash?: string | undefined;
    emailVerified?: boolean;
    createdAt?: Date;
    preferredName?: string | undefined;

    constructor(data?: IUserInfo2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailHash = _data["emailHash"];
            this.emailVerified = _data["emailVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.preferredName = _data["preferredName"];
        }
    }

    static fromJS(data: any): UserInfo2 {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfo2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailHash"] = this.emailHash;
        data["emailVerified"] = this.emailVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["preferredName"] = this.preferredName;
        return data;
    }
}

export interface IUserInfo2 {
    id?: string;
    emailHash?: string | undefined;
    emailVerified?: boolean;
    createdAt?: Date;
    preferredName?: string | undefined;
}

export class OAuthLoginRequest implements IOAuthLoginRequest {
    provider!: string;
    authorizationCode!: string;
    redirectUri?: string | undefined;
    rememberMe?: boolean;

    constructor(data?: IOAuthLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.authorizationCode = _data["authorizationCode"];
            this.redirectUri = _data["redirectUri"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): OAuthLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["authorizationCode"] = this.authorizationCode;
        data["redirectUri"] = this.redirectUri;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface IOAuthLoginRequest {
    provider: string;
    authorizationCode: string;
    redirectUri?: string | undefined;
    rememberMe?: boolean;
}

export class RefreshTokenResponse implements IRefreshTokenResponse {
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: Date;

    constructor(data?: IRefreshTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RefreshTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRefreshTokenResponse {
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: Date;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;
}

export class RegisterRequest implements IRegisterRequest {
    email!: string;
    password!: string;
    confirmPassword!: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IRegisterRequest {
    email: string;
    password: string;
    confirmPassword: string;
}

export class VerificationResponse implements IVerificationResponse {
    message?: string;
    success?: boolean;

    constructor(data?: IVerificationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): VerificationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VerificationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["success"] = this.success;
        return data;
    }
}

export interface IVerificationResponse {
    message?: string;
    success?: boolean;
}

export class ResendVerificationRequest implements IResendVerificationRequest {
    email!: string;

    constructor(data?: IResendVerificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendVerificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendVerificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendVerificationRequest {
    email: string;
}

export class VerifyEmailRequest implements IVerifyEmailRequest {
    token!: string;

    constructor(data?: IVerifyEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): VerifyEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IVerifyEmailRequest {
    token: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}